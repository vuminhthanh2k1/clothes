"use strict";
/**
 * plan-de-transport-api
 * plan-de-transport-api
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagApiFactory = exports.TagApi = exports.TagApiFp = exports.TagApiFetchParamCreator = exports.FeedbackApiFactory = exports.FeedbackApi = exports.FeedbackApiFp = exports.FeedbackApiFetchParamCreator = exports.FavorisClothesApiFactory = exports.FavorisClothesApi = exports.FavorisClothesApiFp = exports.FavorisClothesApiFetchParamCreator = exports.ContainerApiFactory = exports.ContainerApi = exports.ContainerApiFp = exports.ContainerApiFetchParamCreator = exports.ContactApiFactory = exports.ContactApi = exports.ContactApiFp = exports.ContactApiFetchParamCreator = exports.ClothesApiFactory = exports.ClothesApi = exports.ClothesApiFp = exports.ClothesApiFetchParamCreator = exports.CategoryProductApiFactory = exports.CategoryProductApi = exports.CategoryProductApiFp = exports.CategoryProductApiFetchParamCreator = exports.CartClothesApiFactory = exports.CartClothesApi = exports.CartClothesApiFp = exports.CartClothesApiFetchParamCreator = exports.CartApiFactory = exports.CartApi = exports.CartApiFp = exports.CartApiFetchParamCreator = exports.BlogApiFactory = exports.BlogApi = exports.BlogApiFp = exports.BlogApiFetchParamCreator = exports.AccountTokenApiFactory = exports.AccountTokenApi = exports.AccountTokenApiFp = exports.AccountTokenApiFetchParamCreator = exports.AccountApiFactory = exports.AccountApi = exports.AccountApiFp = exports.AccountApiFetchParamCreator = exports.BaseAPI = void 0;
const querystring = require("querystring");
const url = require("url");
const isomorphicFetch = require("isomorphic-fetch");
const assign = require("core-js/library/fn/object/assign");
const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");
class BaseAPI {
    basePath;
    fetch;
    constructor(fetch = isomorphicFetch, basePath = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 * AccountApi - fetch parameter creator
 */
exports.AccountApiFetchParamCreator = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling accountChangeRole");
        }
        const baseUrl = `/Accounts/change-role`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "data": params["data"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        const baseUrl = `/Accounts/get-me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountApi - functional programming interface
 */
exports.AccountApiFp = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangeRole(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountGetMe(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogout(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountApi - object-oriented interface
 */
class AccountApi extends BaseAPI {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        return exports.AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        return exports.AccountApiFp.accountChangeRole(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        return exports.AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        return exports.AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        return exports.AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        return exports.AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        return exports.AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        return exports.AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        return exports.AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        return exports.AccountApiFp.accountGetMe(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        return exports.AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        return exports.AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        return exports.AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        return exports.AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        return exports.AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        return exports.AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        return exports.AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        return exports.AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountApi = AccountApi;
;
/**
 * AccountApi - factory interface
 */
const AccountApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Change a user's password.
         * @param oldPassword
         * @param newPassword
         */
        accountChangePassword(params, options) {
            return exports.AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Change role of user
         * @param data context of request
         */
        accountChangeRole(params, options) {
            return exports.AccountApiFp.accountChangeRole(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm a user registration with identity verification token.
         * @param uid
         * @param token
         * @param redirect
         */
        accountConfirm(params, options) {
            return exports.AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params, options) {
            return exports.AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params, options) {
            return exports.AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamGetAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamPostAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params, options) {
            return exports.AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params, options) {
            return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params, options) {
            return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params, options) {
            return exports.AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params, options) {
            return exports.AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params, options) {
            return exports.AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get account by token
         */
        accountGetMe(options) {
            return exports.AccountApiFp.accountGetMe(options)(fetch, basePath);
        },
        /**
         *
         * @summary Login a user with username/email and password.
         * @param credentials
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params, options) {
            return exports.AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logout a user with access token.
         */
        accountLogout(options) {
            return exports.AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params, options) {
            return exports.AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeLinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params, options) {
            return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data
         */
        accountPrototypeUpdateByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeUpdateByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params, options) {
            return exports.AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password for a user with email.
         * @param options
         */
        accountResetPassword(params, options) {
            return exports.AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset user's password via a password-reset token.
         * @param newPassword
         */
        accountSetPassword(params, options) {
            return exports.AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params, options) {
            return exports.AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params, options) {
            return exports.AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountTokenApi - fetch parameter creator
 */
exports.AccountTokenApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenDeleteById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists");
        }
        const baseUrl = `/AccountTokens/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsHeadAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenFindById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountTokens/{id}/user`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace");
        }
        const baseUrl = `/AccountTokens/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountTokenApi - functional programming interface
 */
exports.AccountTokenApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountTokenApi - object-oriented interface
 */
class AccountTokenApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        return exports.AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        return exports.AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountTokenApi = AccountTokenApi;
;
/**
 * AccountTokenApi - factory interface
 */
const AccountTokenApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params, options) {
            return exports.AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params, options) {
            return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params, options) {
            return exports.AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh
         */
        accountTokenPrototypeGetUser(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountTokenApiFactory = AccountTokenApiFactory;
/**
 * BlogApi - fetch parameter creator
 */
exports.BlogApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params, options) {
        const baseUrl = `/Blogs/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamGetBlogsChangeStream(params, options) {
        const baseUrl = `/Blogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamPostBlogsChangeStream(params, options) {
        const baseUrl = `/Blogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogDeleteById");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogExistsGetBlogsidExists");
        }
        const baseUrl = `/Blogs/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogExistsHeadBlogsid");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogFindById");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params, options) {
        const baseUrl = `/Blogs/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypeGetAccount");
        }
        const baseUrl = `/Blogs/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetTag(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypeGetTag");
        }
        const baseUrl = `/Blogs/{id}/tag`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypePatchAttributes");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogReplaceByIdPostBlogsidReplace");
        }
        const baseUrl = `/Blogs/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogReplaceByIdPutBlogsid");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
        const baseUrl = `/Blogs/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params, options) {
        const baseUrl = `/Blogs/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params, options) {
        const baseUrl = `/Blogs/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * BlogApi - functional programming interface
 */
exports.BlogApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamGetBlogsChangeStream(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCreateChangeStreamGetBlogsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamPostBlogsChangeStream(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCreateChangeStreamPostBlogsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogExistsGetBlogsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogExistsHeadBlogsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetAccount(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetTag(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPrototypeGetTag(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceByIdPostBlogsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceByIdPutBlogsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceOrCreatePutBlogs(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * BlogApi - object-oriented interface
 */
class BlogApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params, options) {
        return exports.BlogApiFp.blogCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params, options) {
        return exports.BlogApiFp.blogCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamGetBlogsChangeStream(params, options) {
        return exports.BlogApiFp.blogCreateChangeStreamGetBlogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamPostBlogsChangeStream(params, options) {
        return exports.BlogApiFp.blogCreateChangeStreamPostBlogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params, options) {
        return exports.BlogApiFp.blogDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params, options) {
        return exports.BlogApiFp.blogExistsGetBlogsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params, options) {
        return exports.BlogApiFp.blogExistsHeadBlogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params, options) {
        return exports.BlogApiFp.blogFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params, options) {
        return exports.BlogApiFp.blogFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params, options) {
        return exports.BlogApiFp.blogFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params, options) {
        return exports.BlogApiFp.blogPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetAccount(params, options) {
        return exports.BlogApiFp.blogPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetTag(params, options) {
        return exports.BlogApiFp.blogPrototypeGetTag(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params, options) {
        return exports.BlogApiFp.blogPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params, options) {
        return exports.BlogApiFp.blogReplaceByIdPostBlogsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params, options) {
        return exports.BlogApiFp.blogReplaceByIdPutBlogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
        return exports.BlogApiFp.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params, options) {
        return exports.BlogApiFp.blogReplaceOrCreatePutBlogs(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params, options) {
        return exports.BlogApiFp.blogUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params, options) {
        return exports.BlogApiFp.blogUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.BlogApi = BlogApi;
;
/**
 * BlogApi - factory interface
 */
const BlogApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        blogCount(params, options) {
            return exports.BlogApiFp.blogCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        blogCreate(params, options) {
            return exports.BlogApiFp.blogCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        blogCreateChangeStreamGetBlogsChangeStream(params, options) {
            return exports.BlogApiFp.blogCreateChangeStreamGetBlogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        blogCreateChangeStreamPostBlogsChangeStream(params, options) {
            return exports.BlogApiFp.blogCreateChangeStreamPostBlogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        blogDeleteById(params, options) {
            return exports.BlogApiFp.blogDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        blogExistsGetBlogsidExists(params, options) {
            return exports.BlogApiFp.blogExistsGetBlogsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        blogExistsHeadBlogsid(params, options) {
            return exports.BlogApiFp.blogExistsHeadBlogsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        blogFind(params, options) {
            return exports.BlogApiFp.blogFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        blogFindById(params, options) {
            return exports.BlogApiFp.blogFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        blogFindOne(params, options) {
            return exports.BlogApiFp.blogFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogPatchOrCreate(params, options) {
            return exports.BlogApiFp.blogPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Blog id
         * @param refresh
         */
        blogPrototypeGetAccount(params, options) {
            return exports.BlogApiFp.blogPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation tag.
         * @param id Blog id
         * @param refresh
         */
        blogPrototypeGetTag(params, options) {
            return exports.BlogApiFp.blogPrototypeGetTag(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Blog id
         * @param data An object of model property name/value pairs
         */
        blogPrototypePatchAttributes(params, options) {
            return exports.BlogApiFp.blogPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        blogReplaceByIdPostBlogsidReplace(params, options) {
            return exports.BlogApiFp.blogReplaceByIdPostBlogsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        blogReplaceByIdPutBlogsid(params, options) {
            return exports.BlogApiFp.blogReplaceByIdPutBlogsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
            return exports.BlogApiFp.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogReplaceOrCreatePutBlogs(params, options) {
            return exports.BlogApiFp.blogReplaceOrCreatePutBlogs(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        blogUpdateAll(params, options) {
            return exports.BlogApiFp.blogUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        blogUpsertWithWhere(params, options) {
            return exports.BlogApiFp.blogUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.BlogApiFactory = BlogApiFactory;
/**
 * CartApi - fetch parameter creator
 */
exports.CartApiFetchParamCreator = {
    /**
     *
     * @summary check order by account token and product
     * @param product product
     */
    cartAddToCart(params, options) {
        // verify required parameter "product" is set
        if (params["product"] == null) {
            throw new Error("Missing required parameter product when calling cartAddToCart");
        }
        const baseUrl = `/Carts/add-to-cart`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "product": params["product"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary change Amount
     * @param cartId change Amount
     */
    cartChangeAmount(params, options) {
        // verify required parameter "cartId" is set
        if (params["cartId"] == null) {
            throw new Error("Missing required parameter cartId when calling cartChangeAmount");
        }
        const baseUrl = `/Carts/changeAmount`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cartId": params["cartId"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartCount(params, options) {
        const baseUrl = `/Carts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartCreate(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamGetCartsChangeStream(params, options) {
        const baseUrl = `/Carts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamPostCartsChangeStream(params, options) {
        const baseUrl = `/Carts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartDeleteById");
        }
        const baseUrl = `/Carts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsGetCartsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartExistsGetCartsidExists");
        }
        const baseUrl = `/Carts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsHeadCartsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartExistsHeadCartsid");
        }
        const baseUrl = `/Carts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFind(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartFindById");
        }
        const baseUrl = `/Carts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFindOne(params, options) {
        const baseUrl = `/Carts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartPatchOrCreate(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary payment online
     * @param data information payment
     */
    cartPaymentOrder(params, options) {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling cartPaymentOrder");
        }
        const baseUrl = `/Carts/payment-order`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts clothes of Cart.
     * @param id Cart id
     * @param where Criteria to match model instances
     */
    cartPrototypeCountClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeCountClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in clothes of this model.
     * @param id Cart id
     * @param data
     */
    cartPrototypeCreateClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeCreateClothes");
        }
        const baseUrl = `/Carts/{id}/clothes`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all clothes of this model.
     * @param id Cart id
     */
    cartPrototypeDeleteClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeDeleteClothes");
        }
        const baseUrl = `/Carts/{id}/clothes`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeDestroyByIdClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeDestroyByIdClothes");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling cartPrototypeDestroyByIdClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of clothes relation to an item by id.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeExistsClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeExistsClothes");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling cartPrototypeExistsClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeFindByIdClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeFindByIdClothes");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling cartPrototypeFindByIdClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Cart id
     * @param refresh
     */
    cartPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeGetAccount");
        }
        const baseUrl = `/Carts/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries clothes of Cart.
     * @param id Cart id
     * @param filter
     */
    cartPrototypeGetClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeGetClothes");
        }
        const baseUrl = `/Carts/{id}/clothes`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     * @param data
     */
    cartPrototypeLinkClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeLinkClothes");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling cartPrototypeLinkClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Cart id
     * @param data An object of model property name/value pairs
     */
    cartPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypePatchAttributes");
        }
        const baseUrl = `/Carts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the clothes relation to an item by id.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeUnlinkClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeUnlinkClothes");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling cartPrototypeUnlinkClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     * @param data
     */
    cartPrototypeUpdateByIdClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartPrototypeUpdateByIdClothes");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling cartPrototypeUpdateByIdClothes");
        }
        const baseUrl = `/Carts/{id}/clothes/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPostCartsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartReplaceByIdPostCartsidReplace");
        }
        const baseUrl = `/Carts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPutCartsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartReplaceByIdPutCartsid");
        }
        const baseUrl = `/Carts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
        const baseUrl = `/Carts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePutCarts(params, options) {
        const baseUrl = `/Carts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    cartStatisticByAmount(params, options) {
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling cartStatisticByAmount");
        }
        const baseUrl = `/Carts/statistic-amount`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "year": params["year"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    cartStatisticByRevenue(params, options) {
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling cartStatisticByRevenue");
        }
        const baseUrl = `/Carts/statistic-revenue`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "year": params["year"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpdateAll(params, options) {
        const baseUrl = `/Carts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpsertWithWhere(params, options) {
        const baseUrl = `/Carts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * CartApi - functional programming interface
 */
exports.CartApiFp = {
    /**
     *
     * @summary check order by account token and product
     * @param product product
     */
    cartAddToCart(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartAddToCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary change Amount
     * @param cartId change Amount
     */
    cartChangeAmount(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartChangeAmount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartCount(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartCreate(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamGetCartsChangeStream(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCreateChangeStreamGetCartsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamPostCartsChangeStream(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartCreateChangeStreamPostCartsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartDeleteById(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsGetCartsidExists(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartExistsGetCartsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsHeadCartsid(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartExistsHeadCartsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFind(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartFindById(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFindOne(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartPatchOrCreate(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary payment online
     * @param data information payment
     */
    cartPaymentOrder(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPaymentOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts clothes of Cart.
     * @param id Cart id
     * @param where Criteria to match model instances
     */
    cartPrototypeCountClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeCountClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in clothes of this model.
     * @param id Cart id
     * @param data
     */
    cartPrototypeCreateClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeCreateClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all clothes of this model.
     * @param id Cart id
     */
    cartPrototypeDeleteClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeDeleteClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeDestroyByIdClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeDestroyByIdClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of clothes relation to an item by id.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeExistsClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeExistsClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeFindByIdClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeFindByIdClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Cart id
     * @param refresh
     */
    cartPrototypeGetAccount(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries clothes of Cart.
     * @param id Cart id
     * @param filter
     */
    cartPrototypeGetClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeGetClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     * @param data
     */
    cartPrototypeLinkClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeLinkClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Cart id
     * @param data An object of model property name/value pairs
     */
    cartPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the clothes relation to an item by id.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeUnlinkClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeUnlinkClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     * @param data
     */
    cartPrototypeUpdateByIdClothes(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartPrototypeUpdateByIdClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPostCartsidReplace(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceByIdPostCartsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPutCartsid(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceByIdPutCartsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePutCarts(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartReplaceOrCreatePutCarts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    cartStatisticByAmount(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartStatisticByAmount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    cartStatisticByRevenue(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartStatisticByRevenue(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpdateAll(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpsertWithWhere(params, options) {
        const fetchArgs = exports.CartApiFetchParamCreator.cartUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * CartApi - object-oriented interface
 */
class CartApi extends BaseAPI {
    /**
     *
     * @summary check order by account token and product
     * @param product product
     */
    cartAddToCart(params, options) {
        return exports.CartApiFp.cartAddToCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary change Amount
     * @param cartId change Amount
     */
    cartChangeAmount(params, options) {
        return exports.CartApiFp.cartChangeAmount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartCount(params, options) {
        return exports.CartApiFp.cartCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartCreate(params, options) {
        return exports.CartApiFp.cartCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamGetCartsChangeStream(params, options) {
        return exports.CartApiFp.cartCreateChangeStreamGetCartsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartCreateChangeStreamPostCartsChangeStream(params, options) {
        return exports.CartApiFp.cartCreateChangeStreamPostCartsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartDeleteById(params, options) {
        return exports.CartApiFp.cartDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsGetCartsidExists(params, options) {
        return exports.CartApiFp.cartExistsGetCartsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartExistsHeadCartsid(params, options) {
        return exports.CartApiFp.cartExistsHeadCartsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFind(params, options) {
        return exports.CartApiFp.cartFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartFindById(params, options) {
        return exports.CartApiFp.cartFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartFindOne(params, options) {
        return exports.CartApiFp.cartFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartPatchOrCreate(params, options) {
        return exports.CartApiFp.cartPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary payment online
     * @param data information payment
     */
    cartPaymentOrder(params, options) {
        return exports.CartApiFp.cartPaymentOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts clothes of Cart.
     * @param id Cart id
     * @param where Criteria to match model instances
     */
    cartPrototypeCountClothes(params, options) {
        return exports.CartApiFp.cartPrototypeCountClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in clothes of this model.
     * @param id Cart id
     * @param data
     */
    cartPrototypeCreateClothes(params, options) {
        return exports.CartApiFp.cartPrototypeCreateClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all clothes of this model.
     * @param id Cart id
     */
    cartPrototypeDeleteClothes(params, options) {
        return exports.CartApiFp.cartPrototypeDeleteClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeDestroyByIdClothes(params, options) {
        return exports.CartApiFp.cartPrototypeDestroyByIdClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of clothes relation to an item by id.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeExistsClothes(params, options) {
        return exports.CartApiFp.cartPrototypeExistsClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeFindByIdClothes(params, options) {
        return exports.CartApiFp.cartPrototypeFindByIdClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Cart id
     * @param refresh
     */
    cartPrototypeGetAccount(params, options) {
        return exports.CartApiFp.cartPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries clothes of Cart.
     * @param id Cart id
     * @param filter
     */
    cartPrototypeGetClothes(params, options) {
        return exports.CartApiFp.cartPrototypeGetClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     * @param data
     */
    cartPrototypeLinkClothes(params, options) {
        return exports.CartApiFp.cartPrototypeLinkClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Cart id
     * @param data An object of model property name/value pairs
     */
    cartPrototypePatchAttributes(params, options) {
        return exports.CartApiFp.cartPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the clothes relation to an item by id.
     * @param id Cart id
     * @param fk Foreign key for clothes
     */
    cartPrototypeUnlinkClothes(params, options) {
        return exports.CartApiFp.cartPrototypeUnlinkClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for clothes.
     * @param id Cart id
     * @param fk Foreign key for clothes
     * @param data
     */
    cartPrototypeUpdateByIdClothes(params, options) {
        return exports.CartApiFp.cartPrototypeUpdateByIdClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPostCartsidReplace(params, options) {
        return exports.CartApiFp.cartReplaceByIdPostCartsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartReplaceByIdPutCartsid(params, options) {
        return exports.CartApiFp.cartReplaceByIdPutCartsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
        return exports.CartApiFp.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartReplaceOrCreatePutCarts(params, options) {
        return exports.CartApiFp.cartReplaceOrCreatePutCarts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    cartStatisticByAmount(params, options) {
        return exports.CartApiFp.cartStatisticByAmount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    cartStatisticByRevenue(params, options) {
        return exports.CartApiFp.cartStatisticByRevenue(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpdateAll(params, options) {
        return exports.CartApiFp.cartUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartUpsertWithWhere(params, options) {
        return exports.CartApiFp.cartUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.CartApi = CartApi;
;
/**
 * CartApi - factory interface
 */
const CartApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary check order by account token and product
         * @param product product
         */
        cartAddToCart(params, options) {
            return exports.CartApiFp.cartAddToCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary change Amount
         * @param cartId change Amount
         */
        cartChangeAmount(params, options) {
            return exports.CartApiFp.cartChangeAmount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        cartCount(params, options) {
            return exports.CartApiFp.cartCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        cartCreate(params, options) {
            return exports.CartApiFp.cartCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        cartCreateChangeStreamGetCartsChangeStream(params, options) {
            return exports.CartApiFp.cartCreateChangeStreamGetCartsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        cartCreateChangeStreamPostCartsChangeStream(params, options) {
            return exports.CartApiFp.cartCreateChangeStreamPostCartsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        cartDeleteById(params, options) {
            return exports.CartApiFp.cartDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        cartExistsGetCartsidExists(params, options) {
            return exports.CartApiFp.cartExistsGetCartsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        cartExistsHeadCartsid(params, options) {
            return exports.CartApiFp.cartExistsHeadCartsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        cartFind(params, options) {
            return exports.CartApiFp.cartFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        cartFindById(params, options) {
            return exports.CartApiFp.cartFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        cartFindOne(params, options) {
            return exports.CartApiFp.cartFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartPatchOrCreate(params, options) {
            return exports.CartApiFp.cartPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary payment online
         * @param data information payment
         */
        cartPaymentOrder(params, options) {
            return exports.CartApiFp.cartPaymentOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts clothes of Cart.
         * @param id Cart id
         * @param where Criteria to match model instances
         */
        cartPrototypeCountClothes(params, options) {
            return exports.CartApiFp.cartPrototypeCountClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in clothes of this model.
         * @param id Cart id
         * @param data
         */
        cartPrototypeCreateClothes(params, options) {
            return exports.CartApiFp.cartPrototypeCreateClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all clothes of this model.
         * @param id Cart id
         */
        cartPrototypeDeleteClothes(params, options) {
            return exports.CartApiFp.cartPrototypeDeleteClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for clothes.
         * @param id Cart id
         * @param fk Foreign key for clothes
         */
        cartPrototypeDestroyByIdClothes(params, options) {
            return exports.CartApiFp.cartPrototypeDestroyByIdClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of clothes relation to an item by id.
         * @param id Cart id
         * @param fk Foreign key for clothes
         */
        cartPrototypeExistsClothes(params, options) {
            return exports.CartApiFp.cartPrototypeExistsClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for clothes.
         * @param id Cart id
         * @param fk Foreign key for clothes
         */
        cartPrototypeFindByIdClothes(params, options) {
            return exports.CartApiFp.cartPrototypeFindByIdClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Cart id
         * @param refresh
         */
        cartPrototypeGetAccount(params, options) {
            return exports.CartApiFp.cartPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries clothes of Cart.
         * @param id Cart id
         * @param filter
         */
        cartPrototypeGetClothes(params, options) {
            return exports.CartApiFp.cartPrototypeGetClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for clothes.
         * @param id Cart id
         * @param fk Foreign key for clothes
         * @param data
         */
        cartPrototypeLinkClothes(params, options) {
            return exports.CartApiFp.cartPrototypeLinkClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Cart id
         * @param data An object of model property name/value pairs
         */
        cartPrototypePatchAttributes(params, options) {
            return exports.CartApiFp.cartPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the clothes relation to an item by id.
         * @param id Cart id
         * @param fk Foreign key for clothes
         */
        cartPrototypeUnlinkClothes(params, options) {
            return exports.CartApiFp.cartPrototypeUnlinkClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for clothes.
         * @param id Cart id
         * @param fk Foreign key for clothes
         * @param data
         */
        cartPrototypeUpdateByIdClothes(params, options) {
            return exports.CartApiFp.cartPrototypeUpdateByIdClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        cartReplaceByIdPostCartsidReplace(params, options) {
            return exports.CartApiFp.cartReplaceByIdPostCartsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        cartReplaceByIdPutCartsid(params, options) {
            return exports.CartApiFp.cartReplaceByIdPutCartsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartReplaceOrCreatePostCartsReplaceOrCreate(params, options) {
            return exports.CartApiFp.cartReplaceOrCreatePostCartsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartReplaceOrCreatePutCarts(params, options) {
            return exports.CartApiFp.cartReplaceOrCreatePutCarts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary statistic order by year
         * @param year year
         */
        cartStatisticByAmount(params, options) {
            return exports.CartApiFp.cartStatisticByAmount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary statistic order by year
         * @param year year
         */
        cartStatisticByRevenue(params, options) {
            return exports.CartApiFp.cartStatisticByRevenue(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        cartUpdateAll(params, options) {
            return exports.CartApiFp.cartUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        cartUpsertWithWhere(params, options) {
            return exports.CartApiFp.cartUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.CartApiFactory = CartApiFactory;
/**
 * CartClothesApi - fetch parameter creator
 */
exports.CartClothesApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartClothesCount(params, options) {
        const baseUrl = `/CartClothes/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartClothesCreate(params, options) {
        const baseUrl = `/CartClothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options) {
        const baseUrl = `/CartClothes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options) {
        const baseUrl = `/CartClothes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartClothesDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesDeleteById");
        }
        const baseUrl = `/CartClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartClothesExistsGetCartClothesidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesExistsGetCartClothesidExists");
        }
        const baseUrl = `/CartClothes/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartClothesExistsHeadCartClothesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesExistsHeadCartClothesid");
        }
        const baseUrl = `/CartClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartClothesFind(params, options) {
        const baseUrl = `/CartClothes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartClothesFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesFindById");
        }
        const baseUrl = `/CartClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartClothesFindOne(params, options) {
        const baseUrl = `/CartClothes/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get order product in cart by token
     * @param user userId
     */
    cartClothesGetOrder(params, options) {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling cartClothesGetOrder");
        }
        const baseUrl = `/CartClothes/get-order-cart`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "user": params["user"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesPatchOrCreate(params, options) {
        const baseUrl = `/CartClothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation cart.
     * @param id CartClothes id
     * @param refresh
     */
    cartClothesPrototypeGetCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesPrototypeGetCart");
        }
        const baseUrl = `/CartClothes/{id}/cart`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation clothes.
     * @param id CartClothes id
     * @param refresh
     */
    cartClothesPrototypeGetClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesPrototypeGetClothes");
        }
        const baseUrl = `/CartClothes/{id}/clothes`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CartClothes id
     * @param data An object of model property name/value pairs
     */
    cartClothesPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesPrototypePatchAttributes");
        }
        const baseUrl = `/CartClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartClothesReplaceByIdPostCartClothesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesReplaceByIdPostCartClothesidReplace");
        }
        const baseUrl = `/CartClothes/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartClothesReplaceByIdPutCartClothesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling cartClothesReplaceByIdPutCartClothesid");
        }
        const baseUrl = `/CartClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options) {
        const baseUrl = `/CartClothes/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesReplaceOrCreatePutCartClothes(params, options) {
        const baseUrl = `/CartClothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartClothesUpdateAll(params, options) {
        const baseUrl = `/CartClothes/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartClothesUpsertWithWhere(params, options) {
        const baseUrl = `/CartClothes/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * CartClothesApi - functional programming interface
 */
exports.CartClothesApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartClothesCount(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartClothesCreate(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartClothesDeleteById(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartClothesExistsGetCartClothesidExists(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesExistsGetCartClothesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartClothesExistsHeadCartClothesid(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesExistsHeadCartClothesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartClothesFind(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartClothesFindById(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartClothesFindOne(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get order product in cart by token
     * @param user userId
     */
    cartClothesGetOrder(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesGetOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesPatchOrCreate(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation cart.
     * @param id CartClothes id
     * @param refresh
     */
    cartClothesPrototypeGetCart(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesPrototypeGetCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation clothes.
     * @param id CartClothes id
     * @param refresh
     */
    cartClothesPrototypeGetClothes(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesPrototypeGetClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CartClothes id
     * @param data An object of model property name/value pairs
     */
    cartClothesPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartClothesReplaceByIdPostCartClothesidReplace(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesReplaceByIdPostCartClothesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartClothesReplaceByIdPutCartClothesid(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesReplaceByIdPutCartClothesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesReplaceOrCreatePutCartClothes(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesReplaceOrCreatePutCartClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartClothesUpdateAll(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartClothesUpsertWithWhere(params, options) {
        const fetchArgs = exports.CartClothesApiFetchParamCreator.cartClothesUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * CartClothesApi - object-oriented interface
 */
class CartClothesApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    cartClothesCount(params, options) {
        return exports.CartClothesApiFp.cartClothesCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    cartClothesCreate(params, options) {
        return exports.CartClothesApiFp.cartClothesCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options) {
        return exports.CartClothesApiFp.cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options) {
        return exports.CartClothesApiFp.cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    cartClothesDeleteById(params, options) {
        return exports.CartClothesApiFp.cartClothesDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartClothesExistsGetCartClothesidExists(params, options) {
        return exports.CartClothesApiFp.cartClothesExistsGetCartClothesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    cartClothesExistsHeadCartClothesid(params, options) {
        return exports.CartClothesApiFp.cartClothesExistsHeadCartClothesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartClothesFind(params, options) {
        return exports.CartClothesApiFp.cartClothesFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    cartClothesFindById(params, options) {
        return exports.CartClothesApiFp.cartClothesFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    cartClothesFindOne(params, options) {
        return exports.CartClothesApiFp.cartClothesFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get order product in cart by token
     * @param user userId
     */
    cartClothesGetOrder(params, options) {
        return exports.CartClothesApiFp.cartClothesGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesPatchOrCreate(params, options) {
        return exports.CartClothesApiFp.cartClothesPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation cart.
     * @param id CartClothes id
     * @param refresh
     */
    cartClothesPrototypeGetCart(params, options) {
        return exports.CartClothesApiFp.cartClothesPrototypeGetCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation clothes.
     * @param id CartClothes id
     * @param refresh
     */
    cartClothesPrototypeGetClothes(params, options) {
        return exports.CartClothesApiFp.cartClothesPrototypeGetClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CartClothes id
     * @param data An object of model property name/value pairs
     */
    cartClothesPrototypePatchAttributes(params, options) {
        return exports.CartClothesApiFp.cartClothesPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartClothesReplaceByIdPostCartClothesidReplace(params, options) {
        return exports.CartClothesApiFp.cartClothesReplaceByIdPostCartClothesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    cartClothesReplaceByIdPutCartClothesid(params, options) {
        return exports.CartClothesApiFp.cartClothesReplaceByIdPutCartClothesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options) {
        return exports.CartClothesApiFp.cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    cartClothesReplaceOrCreatePutCartClothes(params, options) {
        return exports.CartClothesApiFp.cartClothesReplaceOrCreatePutCartClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartClothesUpdateAll(params, options) {
        return exports.CartClothesApiFp.cartClothesUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    cartClothesUpsertWithWhere(params, options) {
        return exports.CartClothesApiFp.cartClothesUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.CartClothesApi = CartClothesApi;
;
/**
 * CartClothesApi - factory interface
 */
const CartClothesApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        cartClothesCount(params, options) {
            return exports.CartClothesApiFp.cartClothesCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        cartClothesCreate(params, options) {
            return exports.CartClothesApiFp.cartClothesCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options) {
            return exports.CartClothesApiFp.cartClothesCreateChangeStreamGetCartClothesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options) {
            return exports.CartClothesApiFp.cartClothesCreateChangeStreamPostCartClothesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        cartClothesDeleteById(params, options) {
            return exports.CartClothesApiFp.cartClothesDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        cartClothesExistsGetCartClothesidExists(params, options) {
            return exports.CartClothesApiFp.cartClothesExistsGetCartClothesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        cartClothesExistsHeadCartClothesid(params, options) {
            return exports.CartClothesApiFp.cartClothesExistsHeadCartClothesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        cartClothesFind(params, options) {
            return exports.CartClothesApiFp.cartClothesFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        cartClothesFindById(params, options) {
            return exports.CartClothesApiFp.cartClothesFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        cartClothesFindOne(params, options) {
            return exports.CartClothesApiFp.cartClothesFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get order product in cart by token
         * @param user userId
         */
        cartClothesGetOrder(params, options) {
            return exports.CartClothesApiFp.cartClothesGetOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartClothesPatchOrCreate(params, options) {
            return exports.CartClothesApiFp.cartClothesPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation cart.
         * @param id CartClothes id
         * @param refresh
         */
        cartClothesPrototypeGetCart(params, options) {
            return exports.CartClothesApiFp.cartClothesPrototypeGetCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation clothes.
         * @param id CartClothes id
         * @param refresh
         */
        cartClothesPrototypeGetClothes(params, options) {
            return exports.CartClothesApiFp.cartClothesPrototypeGetClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id CartClothes id
         * @param data An object of model property name/value pairs
         */
        cartClothesPrototypePatchAttributes(params, options) {
            return exports.CartClothesApiFp.cartClothesPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        cartClothesReplaceByIdPostCartClothesidReplace(params, options) {
            return exports.CartClothesApiFp.cartClothesReplaceByIdPostCartClothesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        cartClothesReplaceByIdPutCartClothesid(params, options) {
            return exports.CartClothesApiFp.cartClothesReplaceByIdPutCartClothesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options) {
            return exports.CartClothesApiFp.cartClothesReplaceOrCreatePostCartClothesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        cartClothesReplaceOrCreatePutCartClothes(params, options) {
            return exports.CartClothesApiFp.cartClothesReplaceOrCreatePutCartClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        cartClothesUpdateAll(params, options) {
            return exports.CartClothesApiFp.cartClothesUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        cartClothesUpsertWithWhere(params, options) {
            return exports.CartClothesApiFp.cartClothesUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.CartClothesApiFactory = CartClothesApiFactory;
/**
 * CategoryProductApi - fetch parameter creator
 */
exports.CategoryProductApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params, options) {
        const baseUrl = `/CategoryProducts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
        const baseUrl = `/CategoryProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
        const baseUrl = `/CategoryProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductDeleteById");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductExistsGetCategoryProductsidExists");
        }
        const baseUrl = `/CategoryProducts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductExistsHeadCategoryProductsid");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductFindById");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params, options) {
        const baseUrl = `/CategoryProducts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductPrototypePatchAttributes");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductReplaceByIdPostCategoryProductsidReplace");
        }
        const baseUrl = `/CategoryProducts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductReplaceByIdPutCategoryProductsid");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
        const baseUrl = `/CategoryProducts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params, options) {
        const baseUrl = `/CategoryProducts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params, options) {
        const baseUrl = `/CategoryProducts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * CategoryProductApi - functional programming interface
 */
exports.CategoryProductApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductExistsGetCategoryProductsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductExistsHeadCategoryProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceByIdPutCategoryProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceOrCreatePutCategoryProducts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * CategoryProductApi - object-oriented interface
 */
class CategoryProductApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params, options) {
        return exports.CategoryProductApiFp.categoryProductCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params, options) {
        return exports.CategoryProductApiFp.categoryProductCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
        return exports.CategoryProductApiFp.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
        return exports.CategoryProductApiFp.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params, options) {
        return exports.CategoryProductApiFp.categoryProductDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params, options) {
        return exports.CategoryProductApiFp.categoryProductExistsGetCategoryProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params, options) {
        return exports.CategoryProductApiFp.categoryProductExistsHeadCategoryProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params, options) {
        return exports.CategoryProductApiFp.categoryProductFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params, options) {
        return exports.CategoryProductApiFp.categoryProductFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params, options) {
        return exports.CategoryProductApiFp.categoryProductFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params, options) {
        return exports.CategoryProductApiFp.categoryProductPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params, options) {
        return exports.CategoryProductApiFp.categoryProductPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceByIdPutCategoryProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePutCategoryProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params, options) {
        return exports.CategoryProductApiFp.categoryProductUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params, options) {
        return exports.CategoryProductApiFp.categoryProductUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.CategoryProductApi = CategoryProductApi;
;
/**
 * CategoryProductApi - factory interface
 */
const CategoryProductApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        categoryProductCount(params, options) {
            return exports.CategoryProductApiFp.categoryProductCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        categoryProductCreate(params, options) {
            return exports.CategoryProductApiFp.categoryProductCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
            return exports.CategoryProductApiFp.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
            return exports.CategoryProductApiFp.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        categoryProductDeleteById(params, options) {
            return exports.CategoryProductApiFp.categoryProductDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        categoryProductExistsGetCategoryProductsidExists(params, options) {
            return exports.CategoryProductApiFp.categoryProductExistsGetCategoryProductsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        categoryProductExistsHeadCategoryProductsid(params, options) {
            return exports.CategoryProductApiFp.categoryProductExistsHeadCategoryProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        categoryProductFind(params, options) {
            return exports.CategoryProductApiFp.categoryProductFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        categoryProductFindById(params, options) {
            return exports.CategoryProductApiFp.categoryProductFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        categoryProductFindOne(params, options) {
            return exports.CategoryProductApiFp.categoryProductFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductPatchOrCreate(params, options) {
            return exports.CategoryProductApiFp.categoryProductPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id CategoryProduct id
         * @param data An object of model property name/value pairs
         */
        categoryProductPrototypePatchAttributes(params, options) {
            return exports.CategoryProductApiFp.categoryProductPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        categoryProductReplaceByIdPutCategoryProductsid(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceByIdPutCategoryProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePutCategoryProducts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        categoryProductUpdateAll(params, options) {
            return exports.CategoryProductApiFp.categoryProductUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        categoryProductUpsertWithWhere(params, options) {
            return exports.CategoryProductApiFp.categoryProductUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.CategoryProductApiFactory = CategoryProductApiFactory;
/**
 * ClothesApi - fetch parameter creator
 */
exports.ClothesApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    clothesCount(params, options) {
        const baseUrl = `/Clothes/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    clothesCreate(params, options) {
        const baseUrl = `/Clothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    clothesCreateChangeStreamGetClothesChangeStream(params, options) {
        const baseUrl = `/Clothes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    clothesCreateChangeStreamPostClothesChangeStream(params, options) {
        const baseUrl = `/Clothes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    clothesDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesDeleteById");
        }
        const baseUrl = `/Clothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    clothesExistsGetClothesidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesExistsGetClothesidExists");
        }
        const baseUrl = `/Clothes/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    clothesExistsHeadClothesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesExistsHeadClothesid");
        }
        const baseUrl = `/Clothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    clothesFind(params, options) {
        const baseUrl = `/Clothes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    clothesFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesFindById");
        }
        const baseUrl = `/Clothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    clothesFindOne(params, options) {
        const baseUrl = `/Clothes/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesPatchOrCreate(params, options) {
        const baseUrl = `/Clothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts cart of Clothes.
     * @param id Clothes id
     * @param where Criteria to match model instances
     */
    clothesPrototypeCountCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeCountCart");
        }
        const baseUrl = `/Clothes/{id}/cart/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Clothes id
     * @param data
     */
    clothesPrototypeCreateCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeCreateCart");
        }
        const baseUrl = `/Clothes/{id}/cart`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all cart of this model.
     * @param id Clothes id
     */
    clothesPrototypeDeleteCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeDeleteCart");
        }
        const baseUrl = `/Clothes/{id}/cart`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeDestroyByIdCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeDestroyByIdCart");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling clothesPrototypeDestroyByIdCart");
        }
        const baseUrl = `/Clothes/{id}/cart/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of cart relation to an item by id.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeExistsCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeExistsCart");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling clothesPrototypeExistsCart");
        }
        const baseUrl = `/Clothes/{id}/cart/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeFindByIdCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeFindByIdCart");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling clothesPrototypeFindByIdCart");
        }
        const baseUrl = `/Clothes/{id}/cart/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries cart of Clothes.
     * @param id Clothes id
     * @param filter
     */
    clothesPrototypeGetCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeGetCart");
        }
        const baseUrl = `/Clothes/{id}/cart`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Clothes id
     * @param refresh
     */
    clothesPrototypeGetCategoryProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeGetCategoryProduct");
        }
        const baseUrl = `/Clothes/{id}/categoryProduct`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     * @param data
     */
    clothesPrototypeLinkCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeLinkCart");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling clothesPrototypeLinkCart");
        }
        const baseUrl = `/Clothes/{id}/cart/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Clothes id
     * @param data An object of model property name/value pairs
     */
    clothesPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypePatchAttributes");
        }
        const baseUrl = `/Clothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the cart relation to an item by id.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeUnlinkCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeUnlinkCart");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling clothesPrototypeUnlinkCart");
        }
        const baseUrl = `/Clothes/{id}/cart/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     * @param data
     */
    clothesPrototypeUpdateByIdCart(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesPrototypeUpdateByIdCart");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling clothesPrototypeUpdateByIdCart");
        }
        const baseUrl = `/Clothes/{id}/cart/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    clothesReplaceByIdPostClothesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesReplaceByIdPostClothesidReplace");
        }
        const baseUrl = `/Clothes/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    clothesReplaceByIdPutClothesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling clothesReplaceByIdPutClothesid");
        }
        const baseUrl = `/Clothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options) {
        const baseUrl = `/Clothes/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesReplaceOrCreatePutClothes(params, options) {
        const baseUrl = `/Clothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    clothesUpdateAll(params, options) {
        const baseUrl = `/Clothes/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    clothesUpsertWithWhere(params, options) {
        const baseUrl = `/Clothes/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ClothesApi - functional programming interface
 */
exports.ClothesApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    clothesCount(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    clothesCreate(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    clothesCreateChangeStreamGetClothesChangeStream(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesCreateChangeStreamGetClothesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    clothesCreateChangeStreamPostClothesChangeStream(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesCreateChangeStreamPostClothesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    clothesDeleteById(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    clothesExistsGetClothesidExists(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesExistsGetClothesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    clothesExistsHeadClothesid(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesExistsHeadClothesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    clothesFind(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    clothesFindById(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    clothesFindOne(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesPatchOrCreate(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts cart of Clothes.
     * @param id Clothes id
     * @param where Criteria to match model instances
     */
    clothesPrototypeCountCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeCountCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Clothes id
     * @param data
     */
    clothesPrototypeCreateCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeCreateCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all cart of this model.
     * @param id Clothes id
     */
    clothesPrototypeDeleteCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeDeleteCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeDestroyByIdCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeDestroyByIdCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of cart relation to an item by id.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeExistsCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeExistsCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeFindByIdCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeFindByIdCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries cart of Clothes.
     * @param id Clothes id
     * @param filter
     */
    clothesPrototypeGetCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeGetCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Clothes id
     * @param refresh
     */
    clothesPrototypeGetCategoryProduct(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeGetCategoryProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     * @param data
     */
    clothesPrototypeLinkCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeLinkCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Clothes id
     * @param data An object of model property name/value pairs
     */
    clothesPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the cart relation to an item by id.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeUnlinkCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeUnlinkCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     * @param data
     */
    clothesPrototypeUpdateByIdCart(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesPrototypeUpdateByIdCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    clothesReplaceByIdPostClothesidReplace(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesReplaceByIdPostClothesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    clothesReplaceByIdPutClothesid(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesReplaceByIdPutClothesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesReplaceOrCreatePutClothes(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesReplaceOrCreatePutClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    clothesUpdateAll(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    clothesUpsertWithWhere(params, options) {
        const fetchArgs = exports.ClothesApiFetchParamCreator.clothesUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ClothesApi - object-oriented interface
 */
class ClothesApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    clothesCount(params, options) {
        return exports.ClothesApiFp.clothesCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    clothesCreate(params, options) {
        return exports.ClothesApiFp.clothesCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    clothesCreateChangeStreamGetClothesChangeStream(params, options) {
        return exports.ClothesApiFp.clothesCreateChangeStreamGetClothesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    clothesCreateChangeStreamPostClothesChangeStream(params, options) {
        return exports.ClothesApiFp.clothesCreateChangeStreamPostClothesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    clothesDeleteById(params, options) {
        return exports.ClothesApiFp.clothesDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    clothesExistsGetClothesidExists(params, options) {
        return exports.ClothesApiFp.clothesExistsGetClothesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    clothesExistsHeadClothesid(params, options) {
        return exports.ClothesApiFp.clothesExistsHeadClothesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    clothesFind(params, options) {
        return exports.ClothesApiFp.clothesFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    clothesFindById(params, options) {
        return exports.ClothesApiFp.clothesFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    clothesFindOne(params, options) {
        return exports.ClothesApiFp.clothesFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesPatchOrCreate(params, options) {
        return exports.ClothesApiFp.clothesPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts cart of Clothes.
     * @param id Clothes id
     * @param where Criteria to match model instances
     */
    clothesPrototypeCountCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeCountCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in cart of this model.
     * @param id Clothes id
     * @param data
     */
    clothesPrototypeCreateCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeCreateCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all cart of this model.
     * @param id Clothes id
     */
    clothesPrototypeDeleteCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeDeleteCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeDestroyByIdCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeDestroyByIdCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of cart relation to an item by id.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeExistsCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeExistsCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeFindByIdCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeFindByIdCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries cart of Clothes.
     * @param id Clothes id
     * @param filter
     */
    clothesPrototypeGetCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeGetCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Clothes id
     * @param refresh
     */
    clothesPrototypeGetCategoryProduct(params, options) {
        return exports.ClothesApiFp.clothesPrototypeGetCategoryProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     * @param data
     */
    clothesPrototypeLinkCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeLinkCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Clothes id
     * @param data An object of model property name/value pairs
     */
    clothesPrototypePatchAttributes(params, options) {
        return exports.ClothesApiFp.clothesPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the cart relation to an item by id.
     * @param id Clothes id
     * @param fk Foreign key for cart
     */
    clothesPrototypeUnlinkCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeUnlinkCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for cart.
     * @param id Clothes id
     * @param fk Foreign key for cart
     * @param data
     */
    clothesPrototypeUpdateByIdCart(params, options) {
        return exports.ClothesApiFp.clothesPrototypeUpdateByIdCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    clothesReplaceByIdPostClothesidReplace(params, options) {
        return exports.ClothesApiFp.clothesReplaceByIdPostClothesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    clothesReplaceByIdPutClothesid(params, options) {
        return exports.ClothesApiFp.clothesReplaceByIdPutClothesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options) {
        return exports.ClothesApiFp.clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    clothesReplaceOrCreatePutClothes(params, options) {
        return exports.ClothesApiFp.clothesReplaceOrCreatePutClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    clothesUpdateAll(params, options) {
        return exports.ClothesApiFp.clothesUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    clothesUpsertWithWhere(params, options) {
        return exports.ClothesApiFp.clothesUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ClothesApi = ClothesApi;
;
/**
 * ClothesApi - factory interface
 */
const ClothesApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        clothesCount(params, options) {
            return exports.ClothesApiFp.clothesCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        clothesCreate(params, options) {
            return exports.ClothesApiFp.clothesCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        clothesCreateChangeStreamGetClothesChangeStream(params, options) {
            return exports.ClothesApiFp.clothesCreateChangeStreamGetClothesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        clothesCreateChangeStreamPostClothesChangeStream(params, options) {
            return exports.ClothesApiFp.clothesCreateChangeStreamPostClothesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        clothesDeleteById(params, options) {
            return exports.ClothesApiFp.clothesDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        clothesExistsGetClothesidExists(params, options) {
            return exports.ClothesApiFp.clothesExistsGetClothesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        clothesExistsHeadClothesid(params, options) {
            return exports.ClothesApiFp.clothesExistsHeadClothesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        clothesFind(params, options) {
            return exports.ClothesApiFp.clothesFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        clothesFindById(params, options) {
            return exports.ClothesApiFp.clothesFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        clothesFindOne(params, options) {
            return exports.ClothesApiFp.clothesFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        clothesPatchOrCreate(params, options) {
            return exports.ClothesApiFp.clothesPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts cart of Clothes.
         * @param id Clothes id
         * @param where Criteria to match model instances
         */
        clothesPrototypeCountCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeCountCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in cart of this model.
         * @param id Clothes id
         * @param data
         */
        clothesPrototypeCreateCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeCreateCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all cart of this model.
         * @param id Clothes id
         */
        clothesPrototypeDeleteCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeDeleteCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for cart.
         * @param id Clothes id
         * @param fk Foreign key for cart
         */
        clothesPrototypeDestroyByIdCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeDestroyByIdCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of cart relation to an item by id.
         * @param id Clothes id
         * @param fk Foreign key for cart
         */
        clothesPrototypeExistsCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeExistsCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for cart.
         * @param id Clothes id
         * @param fk Foreign key for cart
         */
        clothesPrototypeFindByIdCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeFindByIdCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries cart of Clothes.
         * @param id Clothes id
         * @param filter
         */
        clothesPrototypeGetCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeGetCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation categoryProduct.
         * @param id Clothes id
         * @param refresh
         */
        clothesPrototypeGetCategoryProduct(params, options) {
            return exports.ClothesApiFp.clothesPrototypeGetCategoryProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for cart.
         * @param id Clothes id
         * @param fk Foreign key for cart
         * @param data
         */
        clothesPrototypeLinkCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeLinkCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Clothes id
         * @param data An object of model property name/value pairs
         */
        clothesPrototypePatchAttributes(params, options) {
            return exports.ClothesApiFp.clothesPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the cart relation to an item by id.
         * @param id Clothes id
         * @param fk Foreign key for cart
         */
        clothesPrototypeUnlinkCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeUnlinkCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for cart.
         * @param id Clothes id
         * @param fk Foreign key for cart
         * @param data
         */
        clothesPrototypeUpdateByIdCart(params, options) {
            return exports.ClothesApiFp.clothesPrototypeUpdateByIdCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        clothesReplaceByIdPostClothesidReplace(params, options) {
            return exports.ClothesApiFp.clothesReplaceByIdPostClothesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        clothesReplaceByIdPutClothesid(params, options) {
            return exports.ClothesApiFp.clothesReplaceByIdPutClothesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options) {
            return exports.ClothesApiFp.clothesReplaceOrCreatePostClothesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        clothesReplaceOrCreatePutClothes(params, options) {
            return exports.ClothesApiFp.clothesReplaceOrCreatePutClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        clothesUpdateAll(params, options) {
            return exports.ClothesApiFp.clothesUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        clothesUpsertWithWhere(params, options) {
            return exports.ClothesApiFp.clothesUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ClothesApiFactory = ClothesApiFactory;
/**
 * ContactApi - fetch parameter creator
 */
exports.ContactApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params, options) {
        const baseUrl = `/Contacts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamGetContactsChangeStream(params, options) {
        const baseUrl = `/Contacts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamPostContactsChangeStream(params, options) {
        const baseUrl = `/Contacts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactDeleteById");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactExistsGetContactsidExists");
        }
        const baseUrl = `/Contacts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactExistsHeadContactsid");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactFindById");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params, options) {
        const baseUrl = `/Contacts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactPrototypePatchAttributes");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactReplaceByIdPostContactsidReplace");
        }
        const baseUrl = `/Contacts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactReplaceByIdPutContactsid");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
        const baseUrl = `/Contacts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params, options) {
        const baseUrl = `/Contacts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params, options) {
        const baseUrl = `/Contacts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ContactApi - functional programming interface
 */
exports.ContactApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamGetContactsChangeStream(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCreateChangeStreamGetContactsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamPostContactsChangeStream(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCreateChangeStreamPostContactsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactExistsGetContactsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactExistsHeadContactsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceByIdPostContactsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceByIdPutContactsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceOrCreatePutContacts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ContactApi - object-oriented interface
 */
class ContactApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params, options) {
        return exports.ContactApiFp.contactCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params, options) {
        return exports.ContactApiFp.contactCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamGetContactsChangeStream(params, options) {
        return exports.ContactApiFp.contactCreateChangeStreamGetContactsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamPostContactsChangeStream(params, options) {
        return exports.ContactApiFp.contactCreateChangeStreamPostContactsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params, options) {
        return exports.ContactApiFp.contactDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params, options) {
        return exports.ContactApiFp.contactExistsGetContactsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params, options) {
        return exports.ContactApiFp.contactExistsHeadContactsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params, options) {
        return exports.ContactApiFp.contactFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params, options) {
        return exports.ContactApiFp.contactFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params, options) {
        return exports.ContactApiFp.contactFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params, options) {
        return exports.ContactApiFp.contactPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params, options) {
        return exports.ContactApiFp.contactPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params, options) {
        return exports.ContactApiFp.contactReplaceByIdPostContactsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params, options) {
        return exports.ContactApiFp.contactReplaceByIdPutContactsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
        return exports.ContactApiFp.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params, options) {
        return exports.ContactApiFp.contactReplaceOrCreatePutContacts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params, options) {
        return exports.ContactApiFp.contactUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params, options) {
        return exports.ContactApiFp.contactUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ContactApi = ContactApi;
;
/**
 * ContactApi - factory interface
 */
const ContactApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        contactCount(params, options) {
            return exports.ContactApiFp.contactCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        contactCreate(params, options) {
            return exports.ContactApiFp.contactCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        contactCreateChangeStreamGetContactsChangeStream(params, options) {
            return exports.ContactApiFp.contactCreateChangeStreamGetContactsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        contactCreateChangeStreamPostContactsChangeStream(params, options) {
            return exports.ContactApiFp.contactCreateChangeStreamPostContactsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        contactDeleteById(params, options) {
            return exports.ContactApiFp.contactDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        contactExistsGetContactsidExists(params, options) {
            return exports.ContactApiFp.contactExistsGetContactsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        contactExistsHeadContactsid(params, options) {
            return exports.ContactApiFp.contactExistsHeadContactsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        contactFind(params, options) {
            return exports.ContactApiFp.contactFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        contactFindById(params, options) {
            return exports.ContactApiFp.contactFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        contactFindOne(params, options) {
            return exports.ContactApiFp.contactFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactPatchOrCreate(params, options) {
            return exports.ContactApiFp.contactPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Contact id
         * @param data An object of model property name/value pairs
         */
        contactPrototypePatchAttributes(params, options) {
            return exports.ContactApiFp.contactPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        contactReplaceByIdPostContactsidReplace(params, options) {
            return exports.ContactApiFp.contactReplaceByIdPostContactsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        contactReplaceByIdPutContactsid(params, options) {
            return exports.ContactApiFp.contactReplaceByIdPutContactsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
            return exports.ContactApiFp.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactReplaceOrCreatePutContacts(params, options) {
            return exports.ContactApiFp.contactReplaceOrCreatePutContacts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        contactUpdateAll(params, options) {
            return exports.ContactApiFp.contactUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        contactUpsertWithWhere(params, options) {
            return exports.ContactApiFp.contactUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ContactApiFactory = ContactApiFactory;
/**
 * ContainerApi - fetch parameter creator
 */
exports.ContainerApiFetchParamCreator = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ContainerApi - functional programming interface
 */
exports.ContainerApiFp = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ContainerApi - object-oriented interface
 */
class ContainerApi extends BaseAPI {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        return exports.ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        return exports.ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        return exports.ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        return exports.ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     */
    containerGetContainers(options) {
        return exports.ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        return exports.ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        return exports.ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        return exports.ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        return exports.ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
}
exports.ContainerApi = ContainerApi;
;
/**
 * ContainerApi - factory interface
 */
const ContainerApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @param options
         */
        containerCreateContainer(params, options) {
            return exports.ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerDestroyContainer(params, options) {
            return exports.ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerDownload(params, options) {
            return exports.ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetContainer(params, options) {
            return exports.ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         *
         */
        containerGetContainers(options) {
            return exports.ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerGetFile(params, options) {
            return exports.ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetFiles(params, options) {
            return exports.ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerRemoveFile(params, options) {
            return exports.ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerUpload(params, options) {
            return exports.ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};
exports.ContainerApiFactory = ContainerApiFactory;
/**
 * FavorisClothesApi - fetch parameter creator
 */
exports.FavorisClothesApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    favorisClothesCount(params, options) {
        const baseUrl = `/FavorisClothes/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    favorisClothesCreate(params, options) {
        const baseUrl = `/FavorisClothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options) {
        const baseUrl = `/FavorisClothes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options) {
        const baseUrl = `/FavorisClothes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    favorisClothesDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesDeleteById");
        }
        const baseUrl = `/FavorisClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    favorisClothesExistsGetFavorisClothesidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesExistsGetFavorisClothesidExists");
        }
        const baseUrl = `/FavorisClothes/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    favorisClothesExistsHeadFavorisClothesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesExistsHeadFavorisClothesid");
        }
        const baseUrl = `/FavorisClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    favorisClothesFind(params, options) {
        const baseUrl = `/FavorisClothes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    favorisClothesFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesFindById");
        }
        const baseUrl = `/FavorisClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    favorisClothesFindOne(params, options) {
        const baseUrl = `/FavorisClothes/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesPatchOrCreate(params, options) {
        const baseUrl = `/FavorisClothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id FavorisClothes id
     * @param refresh
     */
    favorisClothesPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesPrototypeGetAccount");
        }
        const baseUrl = `/FavorisClothes/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation clothes.
     * @param id FavorisClothes id
     * @param refresh
     */
    favorisClothesPrototypeGetClothes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesPrototypeGetClothes");
        }
        const baseUrl = `/FavorisClothes/{id}/clothes`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id FavorisClothes id
     * @param data An object of model property name/value pairs
     */
    favorisClothesPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesPrototypePatchAttributes");
        }
        const baseUrl = `/FavorisClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesReplaceByIdPostFavorisClothesidReplace");
        }
        const baseUrl = `/FavorisClothes/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    favorisClothesReplaceByIdPutFavorisClothesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling favorisClothesReplaceByIdPutFavorisClothesid");
        }
        const baseUrl = `/FavorisClothes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options) {
        const baseUrl = `/FavorisClothes/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesReplaceOrCreatePutFavorisClothes(params, options) {
        const baseUrl = `/FavorisClothes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    favorisClothesUpdateAll(params, options) {
        const baseUrl = `/FavorisClothes/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    favorisClothesUpsertWithWhere(params, options) {
        const baseUrl = `/FavorisClothes/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * FavorisClothesApi - functional programming interface
 */
exports.FavorisClothesApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    favorisClothesCount(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    favorisClothesCreate(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    favorisClothesDeleteById(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    favorisClothesExistsGetFavorisClothesidExists(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesExistsGetFavorisClothesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    favorisClothesExistsHeadFavorisClothesid(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesExistsHeadFavorisClothesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    favorisClothesFind(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    favorisClothesFindById(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    favorisClothesFindOne(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesPatchOrCreate(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id FavorisClothes id
     * @param refresh
     */
    favorisClothesPrototypeGetAccount(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation clothes.
     * @param id FavorisClothes id
     * @param refresh
     */
    favorisClothesPrototypeGetClothes(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesPrototypeGetClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id FavorisClothes id
     * @param data An object of model property name/value pairs
     */
    favorisClothesPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    favorisClothesReplaceByIdPutFavorisClothesid(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesReplaceByIdPutFavorisClothesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesReplaceOrCreatePutFavorisClothes(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesReplaceOrCreatePutFavorisClothes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    favorisClothesUpdateAll(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    favorisClothesUpsertWithWhere(params, options) {
        const fetchArgs = exports.FavorisClothesApiFetchParamCreator.favorisClothesUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * FavorisClothesApi - object-oriented interface
 */
class FavorisClothesApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    favorisClothesCount(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    favorisClothesCreate(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    favorisClothesDeleteById(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    favorisClothesExistsGetFavorisClothesidExists(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesExistsGetFavorisClothesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    favorisClothesExistsHeadFavorisClothesid(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesExistsHeadFavorisClothesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    favorisClothesFind(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    favorisClothesFindById(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    favorisClothesFindOne(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesPatchOrCreate(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id FavorisClothes id
     * @param refresh
     */
    favorisClothesPrototypeGetAccount(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation clothes.
     * @param id FavorisClothes id
     * @param refresh
     */
    favorisClothesPrototypeGetClothes(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesPrototypeGetClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id FavorisClothes id
     * @param data An object of model property name/value pairs
     */
    favorisClothesPrototypePatchAttributes(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    favorisClothesReplaceByIdPutFavorisClothesid(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesReplaceByIdPutFavorisClothesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    favorisClothesReplaceOrCreatePutFavorisClothes(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesReplaceOrCreatePutFavorisClothes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    favorisClothesUpdateAll(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    favorisClothesUpsertWithWhere(params, options) {
        return exports.FavorisClothesApiFp.favorisClothesUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.FavorisClothesApi = FavorisClothesApi;
;
/**
 * FavorisClothesApi - factory interface
 */
const FavorisClothesApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        favorisClothesCount(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        favorisClothesCreate(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesCreateChangeStreamGetFavorisClothesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesCreateChangeStreamPostFavorisClothesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        favorisClothesDeleteById(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        favorisClothesExistsGetFavorisClothesidExists(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesExistsGetFavorisClothesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        favorisClothesExistsHeadFavorisClothesid(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesExistsHeadFavorisClothesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        favorisClothesFind(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        favorisClothesFindById(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        favorisClothesFindOne(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        favorisClothesPatchOrCreate(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id FavorisClothes id
         * @param refresh
         */
        favorisClothesPrototypeGetAccount(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation clothes.
         * @param id FavorisClothes id
         * @param refresh
         */
        favorisClothesPrototypeGetClothes(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesPrototypeGetClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id FavorisClothes id
         * @param data An object of model property name/value pairs
         */
        favorisClothesPrototypePatchAttributes(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesReplaceByIdPostFavorisClothesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        favorisClothesReplaceByIdPutFavorisClothesid(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesReplaceByIdPutFavorisClothesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesReplaceOrCreatePostFavorisClothesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        favorisClothesReplaceOrCreatePutFavorisClothes(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesReplaceOrCreatePutFavorisClothes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        favorisClothesUpdateAll(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        favorisClothesUpsertWithWhere(params, options) {
            return exports.FavorisClothesApiFp.favorisClothesUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.FavorisClothesApiFactory = FavorisClothesApiFactory;
/**
 * FeedbackApi - fetch parameter creator
 */
exports.FeedbackApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params, options) {
        const baseUrl = `/Feedbacks/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
        const baseUrl = `/Feedbacks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
        const baseUrl = `/Feedbacks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackDeleteById");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackExistsGetFeedbacksidExists");
        }
        const baseUrl = `/Feedbacks/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackExistsHeadFeedbacksid");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackFindById");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params, options) {
        const baseUrl = `/Feedbacks/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh
     */
    feedbackPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackPrototypeGetAccount");
        }
        const baseUrl = `/Feedbacks/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackPrototypePatchAttributes");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackReplaceByIdPostFeedbacksidReplace");
        }
        const baseUrl = `/Feedbacks/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackReplaceByIdPutFeedbacksid");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
        const baseUrl = `/Feedbacks/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params, options) {
        const baseUrl = `/Feedbacks/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params, options) {
        const baseUrl = `/Feedbacks/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * FeedbackApi - functional programming interface
 */
exports.FeedbackApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackExistsGetFeedbacksidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackExistsHeadFeedbacksid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh
     */
    feedbackPrototypeGetAccount(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceByIdPostFeedbacksidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceByIdPutFeedbacksid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceOrCreatePutFeedbacks(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * FeedbackApi - object-oriented interface
 */
class FeedbackApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params, options) {
        return exports.FeedbackApiFp.feedbackCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params, options) {
        return exports.FeedbackApiFp.feedbackCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
        return exports.FeedbackApiFp.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
        return exports.FeedbackApiFp.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params, options) {
        return exports.FeedbackApiFp.feedbackDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params, options) {
        return exports.FeedbackApiFp.feedbackExistsGetFeedbacksidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params, options) {
        return exports.FeedbackApiFp.feedbackExistsHeadFeedbacksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params, options) {
        return exports.FeedbackApiFp.feedbackFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params, options) {
        return exports.FeedbackApiFp.feedbackFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params, options) {
        return exports.FeedbackApiFp.feedbackFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params, options) {
        return exports.FeedbackApiFp.feedbackPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh
     */
    feedbackPrototypeGetAccount(params, options) {
        return exports.FeedbackApiFp.feedbackPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params, options) {
        return exports.FeedbackApiFp.feedbackPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceByIdPostFeedbacksidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceByIdPutFeedbacksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceOrCreatePutFeedbacks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params, options) {
        return exports.FeedbackApiFp.feedbackUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params, options) {
        return exports.FeedbackApiFp.feedbackUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.FeedbackApi = FeedbackApi;
;
/**
 * FeedbackApi - factory interface
 */
const FeedbackApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        feedbackCount(params, options) {
            return exports.FeedbackApiFp.feedbackCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        feedbackCreate(params, options) {
            return exports.FeedbackApiFp.feedbackCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
            return exports.FeedbackApiFp.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
            return exports.FeedbackApiFp.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        feedbackDeleteById(params, options) {
            return exports.FeedbackApiFp.feedbackDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        feedbackExistsGetFeedbacksidExists(params, options) {
            return exports.FeedbackApiFp.feedbackExistsGetFeedbacksidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        feedbackExistsHeadFeedbacksid(params, options) {
            return exports.FeedbackApiFp.feedbackExistsHeadFeedbacksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        feedbackFind(params, options) {
            return exports.FeedbackApiFp.feedbackFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        feedbackFindById(params, options) {
            return exports.FeedbackApiFp.feedbackFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        feedbackFindOne(params, options) {
            return exports.FeedbackApiFp.feedbackFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackPatchOrCreate(params, options) {
            return exports.FeedbackApiFp.feedbackPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Feedback id
         * @param refresh
         */
        feedbackPrototypeGetAccount(params, options) {
            return exports.FeedbackApiFp.feedbackPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Feedback id
         * @param data An object of model property name/value pairs
         */
        feedbackPrototypePatchAttributes(params, options) {
            return exports.FeedbackApiFp.feedbackPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceByIdPostFeedbacksidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        feedbackReplaceByIdPutFeedbacksid(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceByIdPutFeedbacksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackReplaceOrCreatePutFeedbacks(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceOrCreatePutFeedbacks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        feedbackUpdateAll(params, options) {
            return exports.FeedbackApiFp.feedbackUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        feedbackUpsertWithWhere(params, options) {
            return exports.FeedbackApiFp.feedbackUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.FeedbackApiFactory = FeedbackApiFactory;
/**
 * TagApi - fetch parameter creator
 */
exports.TagApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        const baseUrl = `/Tags/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagDeleteById");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagExistsGetTagsidExists");
        }
        const baseUrl = `/Tags/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagExistsHeadTagsid");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagFindById");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        const baseUrl = `/Tags/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagPrototypePatchAttributes");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagReplaceByIdPostTagsidReplace");
        }
        const baseUrl = `/Tags/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagReplaceByIdPutTagsid");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        const baseUrl = `/Tags/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        const baseUrl = `/Tags/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        const baseUrl = `/Tags/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TagApi - functional programming interface
 */
exports.TagApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreateChangeStreamGetTagsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreateChangeStreamPostTagsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagExistsGetTagsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagExistsHeadTagsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceByIdPostTagsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceByIdPutTagsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceOrCreatePutTags(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TagApi - object-oriented interface
 */
class TagApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        return exports.TagApiFp.tagCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        return exports.TagApiFp.tagCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        return exports.TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        return exports.TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        return exports.TagApiFp.tagDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        return exports.TagApiFp.tagExistsGetTagsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        return exports.TagApiFp.tagExistsHeadTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        return exports.TagApiFp.tagFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        return exports.TagApiFp.tagFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        return exports.TagApiFp.tagFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        return exports.TagApiFp.tagPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        return exports.TagApiFp.tagPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        return exports.TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        return exports.TagApiFp.tagReplaceByIdPutTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        return exports.TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        return exports.TagApiFp.tagReplaceOrCreatePutTags(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        return exports.TagApiFp.tagUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        return exports.TagApiFp.tagUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TagApi = TagApi;
;
/**
 * TagApi - factory interface
 */
const TagApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        tagCount(params, options) {
            return exports.TagApiFp.tagCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        tagCreate(params, options) {
            return exports.TagApiFp.tagCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        tagCreateChangeStreamGetTagsChangeStream(params, options) {
            return exports.TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        tagCreateChangeStreamPostTagsChangeStream(params, options) {
            return exports.TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        tagDeleteById(params, options) {
            return exports.TagApiFp.tagDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsGetTagsidExists(params, options) {
            return exports.TagApiFp.tagExistsGetTagsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsHeadTagsid(params, options) {
            return exports.TagApiFp.tagExistsHeadTagsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFind(params, options) {
            return exports.TagApiFp.tagFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        tagFindById(params, options) {
            return exports.TagApiFp.tagFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFindOne(params, options) {
            return exports.TagApiFp.tagFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagPatchOrCreate(params, options) {
            return exports.TagApiFp.tagPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Tag id
         * @param data An object of model property name/value pairs
         */
        tagPrototypePatchAttributes(params, options) {
            return exports.TagApiFp.tagPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPostTagsidReplace(params, options) {
            return exports.TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPutTagsid(params, options) {
            return exports.TagApiFp.tagReplaceByIdPutTagsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
            return exports.TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePutTags(params, options) {
            return exports.TagApiFp.tagReplaceOrCreatePutTags(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpdateAll(params, options) {
            return exports.TagApiFp.tagUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpsertWithWhere(params, options) {
            return exports.TagApiFp.tagUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TagApiFactory = TagApiFactory;
//# sourceMappingURL=api.js.map